# 第五章 - 循环

<div id="box"></div>

这个例子很明显涉及到一个颜色流，和一个用于控制颜色更新的信号流。

颜色流监听信号流当中信号的到来，每当有新的信号时更新自己的值：

```javascript
function colorStream(context) {
  return colorUpdateSignal(context).scan(prev => {
    // ...
  }, 'green');
}
```

那么信号流要如何确定下一个信号到来的时刻呢？在颜色流的值不同时信号到来的间隔也不相同，因此信号流必然需要监听颜色流（暂时忽略按钮的作用）：

```javascript
function colorUpdateSignal(context) {
  return colorStream(context).flatMap(color => {
    // ...
  });
}
```

本章的主题，不是颜色的循环，而是两条流之间的循环依赖。

----

虽然称之为「循环依赖」，不过很显然，这和普通的循环依赖有所不同。

> 好像实际上没有无穷递归，只是因为书写代码时采取了错误的形式。

这种直觉是非常正确的。事实上，每一条流所依赖的，都只是其他流在上一个瞬间的值或是信号，不管形式上循环与否，在每一个时刻的计算开始之前，计算所需要的所有信息一定是已经准备就绪的。可以说，在Butterfly的抽象下，理论上只有一种无法解决的循环依赖：两条或更多条流在计算初始值时依赖于彼此的当前值。只有这种情况下，需要对某些流代表的含义进行调整，否则，最多只需要调整代码的形式即可。

可能你已经发觉了，其实在更小的范围内，一个看似理所应当的逻辑中也含有循环依赖：按钮上的字依赖于按钮被点击的事件，事件的信号流依赖于按钮的视图流，而视图流依赖于按钮上字对应的属性流。我们是怎样解决它的呢？事实上根本没有进行任何意义上的「解决」，只是简单地使用与前面章节完全相同的形式：

{% include_code index.js 43:62 %}

其中`colorStream`的定义我们稍后会看到，而`enableStream`甚至就是`context.eventBus`本身

{% include_code index.js 10:13 %}

正如你所见，`context`还有第二个功能。

将这个技巧进行一定的归纳，我们可以得到又一个「最先加入Butterfly库的工具函数」

{% include_code index.js 75:87 %}

这个函数是如何一步一步抽象出来的，由于~~我懒得写~~篇幅有限，请读者自行推导。一定要注意最后，在`overdraft`函数返回的流被取消订阅时，在清理现场时，要取消对`getObs`函数返回的流的订阅。这个订阅其实对应着另外一条流对`getObs`返回的流的订阅，因此要避免循环订阅导致流没有被正常失活化的情况。当然，以上仅仅针对Kefir的流抽象。

为什么称这个函数为`overdraft`（透支）呢？看看用法就知道了

{% include_code index.js 30:42 %}

`overdraft`函数的参数是一个回调函数`getObs`，这个函数返回的结果（在这里）是`colorStream`，而传递给它的参数……也是`colorStream`！当然，排除掉这一颇具科幻效果的描述，我们可以根据`overdraft`的实现，很明显地了解到，传递给`getObs`的参数其实是用一个`eventBus`伪造的。这也造成了一点不大不小的后果：`eventBus`实际上是一条信号流，而在这个例子里`colorStream`其实是一条属性流。由于对于代码逻辑没有任何影响，在这里我忽略了这一点差异，并且没有给参数单独取一个类似于`colorSignal`之类的蹩脚名字，但它其实是一条信号流。

这里我们也见到了除了`context`以外的其他参数的作用。我很高兴可以见到这些概念发挥了我最初创造它们时没有想到的作用。

----

最后，我们还需要实现`colorUpdateSignal`信号流。这条流的定义是：
* 当`enableStream`的值为真时，在每一个颜色发生切换时，根据新的颜色决定其持续的时间长度
* 当`enableStream`的值变为假时，**丢弃一切计划中的颜色切换**，并且将`enableStream`的值重新变回真的事件**视作颜色刚刚切换至当前颜色的事件**。

这也就意味着：一，当「暂停」按钮被按下以后，颜色将不会再有任何变化；二、如果在红色即将切换为绿色时按下「暂停」，那么在按下「继续」以后，颜色并不会立即切换到绿色，还是要等待红色持续的时间长度。

这样的定义主要是为了避免对「暂停之前当前颜色持续了多久」进行记录。

{% include_code index.js 14:29 %}

红绿灯每一次启动时都会创建一个新的信号流，而这个流会在红绿灯被暂停时终止。最终所有的信号流通过`flatMap`合并到一起。在每一条信号流的内部，同样使用`Kefir.later`为每一次的颜色变换创建一条只有一次信号的信号流，然后通过`flatMap`合并。`enableStream`在过滤之后需要在开头添加一个无延迟的异步信号，这是因为`filter`不会作用在属性流的初始值上。

----

最后补充一点。也许在我以按钮的例子引出使用`context`解决循环依赖的时候，你在想，接下来我会用同样的方式，把`colorUpdateSignal`发射到`context`参数上，然后在`colorStream`中监听`context.eventBus`，然而却发现我的做法是创建了一个专门的局部上下文。为什么不去使用`context`函数呢？

除了显而易见的全局名字所带来的弊端，这种做法最大的问题在于它违背了之前提到的基本原则：状态的变化依赖于事件，而不可以反过来。所有出现在`context.eventBus`总线上的事件，都应当来自于外部世界，例如时间的流逝、用户的行为或者网络活动。将状态的变化发送至时间总线上的做法，看似缓解了处理复杂依赖关系时的心智负担，但实际上会将依赖环扩大，使原本两条流之间的互相依赖影响更多的流，从而使代码逻辑更加错综复杂。虽然Butterfly可以实现中心化的数据store，但是随之而来的麻烦在Butterfly中同样不可小觑。

因此，也许「把它发送到总线上就一切都解决了」的想法看起来相当诱人，但是状态流对事件流的影响是绝对要避免的。至于视图流对事件流，除非是一些非常浅显易懂的情况，比如「页面的初始化等价于点一下这个按钮」，可以在仔细考虑并做好文档的情况下，进行简单地干预以外，大多数情况下还是应该尽量避免。解决问题的方式有很多，快速迭代只是众多方式中的一种，而绝大多数的问题都不是完全适合于被这样解决的。
