# 第三章 - 点灯

<div id="box"></div>

不知道你在第一次尝试点亮页面发现没有反应时的反应如何，希望这个玩笑无伤大雅。

----

在这个例子里，变化的是页面的背景颜色，而电源按钮本身始终保持不变，因此可以作为代码的切入点。

> 那么如果所有的流都是随事件变化，我该从哪开始写呢？

看完这一章（最多下一章），你就会知道问题的答案。

{% include_code index.js 10:19 %}

`styles`是这一章用到的CSS模块。上面出现的`styles.button`定义了按钮的大小和边框，接下来会看到的`styles.turnOff`简单地将背景颜色设为黑色。

这一段代码中至关重要的便是绑定在`onClick`上的回调函数，我们第一次见到`context`参数发挥了作用。通过调用`context.emit`，按钮被点击的事件被`context`所感知。接下来，我们将借助`context`将所有的点击事件重建为一条信号流

{% include_code index.js 20:24 %}

到这里，相信`context`发挥的作用已经显而易见：对`context.emit`的每一调用组成了一条事件流`context.eventBus`，我们可以从这条「信号总线」上把我们需要的信号过滤出来。在这个例子中，会往总线上输送信号的其实只有`buttonViewStream`，但为了演示总线的概念我还是为信号添加了一定的标记。

> 那么，这么好用的`context`对象，一定是由Butterfly提供的咯？

如果到了不得不引入一个工具库的情况，那么这大概会是第一个被加入工具库的功能。可惜，目前来说我们会选择自己创建这个`context`，原因是：
* 它的实现出乎意料的简单，接下来就会看到
* 在这个例子中`context.eventBus`是一个Kefir流，也就是说，创建`context`的代码对Kefir形成了依赖。我暂时还没有想到什么好的办法足够通用化地实现创建`context`的功能而不用引入麻烦的函数签名。

这里顺便一提，在Kefir中有一个`Kefir.fromEvents`函数可以以DOM元素和事件名为参数方便地获得事件的信号流，然而在ReactDOM中我们难以拿到每个虚拟DOM元素对应的真实DOM元素（在其他类似的库中甚至可能是根本无法做到的），并且这从道理上也是说得通的，毕竟真实DOM何时复用何时替换应该是对用户完全透明的。因此，不管在一个Butterfly范式的项目中使用了什么库，都应该尽量尊重虚拟DOM的抽象。这样的选择会导致一部分的库使用起来很困难（如[velocity.js]和[hammer.js]），但我相信总会有办法解决的。

[velocity.js]: http://velocityjs.org
[hammer.js]: https://hammerjs.github.io

有了点击按钮的信号流以后，我们便可以记录按钮被点击的次数，以及，确定当前页面的状态是「开灯」还是「关灯」

{% include_code index.js 25:32 %}

最后，将按钮渲染进页面，并在合适的时刻修改`document.body`的样式类

{% include_code index.js 33:50 %}

`main`函数中除了将根DOM元素挂载入页面以外，还会有一些类似于修改页面标题之类的对全局信息的更新逻辑，算是Web技术的某种瑕疵吧。

最后的最后，我们来看看`getContext`函数的实现

{% include_code index.js 51:64 %}

看懂它需要对Kefir有一定的了解，这里就不多涉及了。这个形式的`getContext`所创建的`context`可以说是除了空对象以外`context`最简单的形式（它甚至不需要是拥有内部状态的对象），接下来的章节中我还会继续用到这个版本的`getContext`，看看它可以走多远。
