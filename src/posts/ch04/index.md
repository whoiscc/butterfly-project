# 第四章 - 宿命

<div id="box"></div>

若想获得更加真实的游戏体验，建议每次把计数器点到20，然后每看20秒文章回去点一次。

> 所谓人生，不过就是一场拆东墙补西墙的伟大冒险。

----

正如上一篇文章所说，在这个例子中我们可以复用`getContext`函数。

{% include_code index.js 7:9 %}

这次的样式`styles.app`是针对整个展示区定义的，用于把数字和按钮显示在同一行。

在这里，我想引入Butterfly中的第二个约定形式，关于组织一篇代码时的逻辑顺序。我们认为，从外部世界首先可以得到的是代表事件的信号流，在这个例子中有两个事件：每秒钟的滴答事件和用户点击按钮的事件

{% include_code index.js 11:18 %}

可以看到，我们先从事件总线上取得了`'clicked'`事件的信号流，在接下来的代码中才去具体交代这些事件是如何出现的。

在取得所有的事件以后，我们便可以通过事件和系统当前的状态，计算得出系统状态流

{% include_code index.js 19:33 %}

其中`positionUpdateSignal`的概念可能会让人感到不安——在通常的前端开发中，从来不会出现这种把定时事件和用户事件合二为一一并处理的机会。这也从侧面体现出，不同的抽象模型一定是各有所长的。接下来`positionStream`的构造方式稍微有点复杂，总而言之我们想要达到的目的是，一旦在某一时刻`positionStream`的值为0，那么`positionUpdateSignal`中新出现的信号将不会再产生任何作用。如果在我们的应用中这是一种频繁出现的流构造逻辑，我们可以考虑将其抽象为一个工具函数或者换一个擅长进行这种流变换的库。

接下来，根据系统状态流，我们可以分别构造数字和按钮的视图流

{% include_code index.js 34:48 %}

这两个函数多接受一个`positionStream`参数，而不是在自己内部通过`positionStream(context)`调用获取系统状态流。这难道是说明系统状态流有什么特殊之处吗？并不是，你可以尝试把这段代码替换成后一种做法，运行结果并不会有什么不同。正如之前所提到的，所有的流构造函数都是纯函数（至少从概念上来说），调用一次并复用结果和调用多次除了性能没有任何区别。

如果真的在两个函数中都写了`positionStream(context)`的话，运行时中将出现两个`positionStream`函数返回的流，这两个流分别调用`positionUpdateSignal`函数构造出两个信号流，同理`tickSignal`和`helpButtonClickedSignal`也会有两个，然后呢？没有然后了。具体到Kefir的实现的话，它会多注册一个定时器，以及多一个对`context.eventBus`的监听者（`context.eventBus`仍然只有一个），没有更多影响了。如果你注意到`tickSignal`并没有用到`context`参数，把它从函数改为一个全局常量的话，那么连定时器都只会有一个。

因此，这里多添加一个`positionStream`参数的目的主要还是为了展示，Butterfly的范式可以在哪些方面在一定程度内变形。规矩就是用来打破的，只要打破的方式得当。

最后，我们将两个子视图流合并为主视图流

{% include_code index.js 49:61 %}

并在`main`函数中将它渲染到`#box`中。`main`函数和第二章一样，这里不再列出。

----

总结一下，目前Butterfly中提出的两个约定：
* 应用代码由一组接受`context`参数的纯函数构成，如果可以带来额外的好处可以接受其它参数，但是一定存在一种不需要其它参数的等价形式
* 通篇代码的思路应该是
  1. 从外部环境得到各种事件的信号流
  2. 从信号流以及初始状态得到各个状态流
  3. 从状态流得到各个视图流并组装为整个页面的视图流

在这个小例子中，一个状态流就完成了对页面状态的描述。当应用复杂时，可以选择采用中心化的状态流模型，即所有的信号流都改变同一个状态流，也就是类似于各个流行框架中store的作用。通过将所有的事件发射到`context.eventBus`上可以方便地实现这一模型。不过，如果没有那么严格的对项目维护性的需求，我认为并不需要把所有的状态集中到一条流中（在下一章也许会看到这样做的麻烦之处），每条状态流只要依赖于真正与之相关的信号流就好了。

----

还记得序言中我用「魔法一二三」描述的抽象世界吗？
