# 中场休息（一） - 观测

这一篇的内容只与Kefir的特性有关，因此不作为单独一章。

在上一章我们简单地涉及了Kefir流的「激活」的概念，我也以「这样就可以避免循环监听了」这样敷衍的语句一笔带过。但事实上，我们接下来不可避免地需要与流的激活与失活打交道，因此在此之前，我决定在这里阐述一个常见的佯谬，并提供一个简单的解决方案。

<div id="box"></div>

要实现这个例子，首先要获取每0.1秒钟递增的计数器以及用户点击按钮的事件流，这与之前的例子非常类似

{% include_code index.js 10:17 %}

接下来，如何构造实际上显示在页面上的数字流呢？一种做法类似于上一章构造颜色更新信号的方式，在每次用户点击「继续」（以及页面刚刚加载）时开启一个新的流，其值与`counterStream`始终保持一致，但是在用户点击「暂停」时终止。（稍后你将看到，上一章的代码居然可以工作是一件多么凑巧的事……）

```javascript
// 这样对吗？
function numberStream(context) {
  return enableStream(context).filter().flatMap(enable => {
    return counterStream(context).takeUntilBy(
      enableStream(context).filter(enable => !enable));
  });
}
```

这样对吗？上面的代码中有一个明显的问题：`flatMap`在每一个信号到达时执行回调函数获得一条新流，而重复调用`counterStream`会使计数重复归零。

> 你不是说，它们都是纯函数吗？调用多次和调用一次的结果是一样的吗？

显然，当我们把「时间」搅和进我们的模型时，一些违背常识的现象出现了。作为纯函数的著名特性，「调用多次等价于调用一次并复用结果」这句话是不会有问题的——当你假设你的程序在瞬间完成时。我从来没有把「Butterfly中所有的抽象都是纯函数」作为一个值得夸耀的卖点，仅仅是用了一个已经存在于读者脑海中的概念来帮助理解。「它们都是纯函数」这一点本身对于降低问题的难度并没有任何帮助。

说回我们遇到的问题。很直接的，我们可以把`counterStream`和`enableStream`提取到`flatMap`的外面，让它们只在`numberStream`初始化时被构建一次

```javascript
// 这回呢？
function numberStream(context) {
  const enableStream_ = enableStream(context);
  const counterStream_ = counterStream(context);
  return enableStream_.filter().flatMap(enable => {
    return counterStream_.takeUntilBy(
      enableStream_.filter(enable => !enable));
  });
}
```

如果你真的把这段代码运行起来，你会发现，当你点下「继续」时，页面上的数字没有跳过暂停的这段时间，而是接着走了下去，暂停的时间消失了。这就是由于Kefir流的激活机制导致的。

----

借用《物语》系列中的观点，妖怪之所以存在，是因为人们「相信」它们是存在的。借用《寻梦环游记》中的观点，故去的人们之所以存在，是因为活着的人们还记得他们。「世界是因为观测才存在的」这种观点在近来的文学作品中越来越常见，作为某种巧合，它也可以用来描述Kefir的激活机制。

> 其实只是希望《物语》出现在我的文章中而已。

我们称一条流是被「观测」的，当且仅当我们调用了它的`observe`方法，并且还没有在返回的句柄上调用`unsubscribe`方法。一条流仅仅在被观测时才处于「激活」状态，此外的时间里都是「失活」的。拿`Kefir.interval`为例，在它的一个实例被激活时，它会调用JavaScript的`setInterval`函数，而当它转为失活状态时，它会调用`clearInterval`将定时器取消。因此，如果你在下一个信号即将到来时取消了对一条`Kefir.interval`流的订阅，然后又重新开始监听，你会发现你还是需要等待与参数等长的时间才能收到第一个信号——有关于上次激活的信息完全丢失了。如果一条流是通过`Kefir.stream`自定义的，那么在它被激活时传入的回调函数会被执行，而这个回调函数返回的回调函数会在流失活时被执行。有关于激活与失活的正式介绍请参考[Kefir的文档][1]。

[1]: https://kefirjs.github.io/kefir/#active-state

> 可是整篇代码里构造了那么多流，只调用了一次`observe`方法呀？

流的激活是链式依赖的。如果一条流是通过调用另一条流的方法，比如`map`或是`flatMap`构造的，那么这条流被激活时它所依赖的流也会被激活；如果一条流通过`Kefir.merge`等函数依赖于多条流，那么所有被依赖的流都会在它被激活时被激活。因此，当所有的流之间形成了树状的依赖关系时，点亮了根视图流组成的树根，就会点亮各子视图流，从而点亮各状态流，最终使所有的事件流都被激活。同时，状态流通常都是属性流，它们的初值会立刻被交给视图流用来绘制页面的初始状态。这便是一个Butterfly页面典型的启动过程。

事实上，每一个例子中的`main`函数（好久没有见到它了）也仿照了`Kefir.stream`函数的形式。这也就是为什么第一章和第三章的`main`函数最终不需要返回`() => subscription.unsubscribe()`而其他的例子就需要的原因——如果不取消对根视图流的订阅，它就会使`tickSignal`一直保持在激活状态而不停输出信号，从而在页面已经切换之后依然在继续计算展示区的视图。而第一章的例子根本不会动，第三章的例子只在用户点击按钮时更新，在例子被切换以后按钮被从页面上移除了，自然无法再更新了。

> 当然，会造成内存泄漏是肯定的。

另外提一点，当一个流构造函数有可能不是在页面初始化时被执行时，传入一个已经构造好的流作为参数和在其内部调用其它流构造函数自行构造需要的流，两者的行为可能是完全不同的。因此在这种情况下两者无法随意替换，这是我最初没有想到的。今后所有除`context`以外的参数，如果是流构造函数（以后模块化时可能会出现），则与对应的流的名字相同；如果是构造好的流（之前的所有情况），就在名字的结尾加一条下划线，如`enableStream_`，局部变量的命名同理。

----

如果按照上面的写法，每当「继续」按钮被按下时创建一条流监听`enableStream`和`counterStream`，每当「暂停」按钮被按下时将其终止，会发生什么呢？

在暂停到继续的这段时间里，没有流在监听`enableStream`和`counterStream`，它们暂时地「消失」了。

因此，虽然我们将两条流在页面初始化时就构造好了，但是它们还是会在每次「继续」时被重新初始化一遍（因为刚刚从失活状态切换到激活状态），我们所进行的提前构造没有起到作用。`enableStream`奇迹般地恰好可以工作（这就是上一章的例子可以运行的原因），而`counterStream`就没这么幸运：没有人观测它的时间里，它停止递增，停留在暂停前的值，直到下一个被创建的流出现。

如何解决这个现象呢？

首先要搞清楚，这种现象不总是我们不想要的。因此，我们应该提供一种方式使其不发生，而不是彻底消灭它的存在。一种最简单的方式就是，在整个`numberStream`被监听的周期内，创建一个「稻草人」，监听这两条流而不进行任何操作，并且在`numberStream`被取消订阅的时候也取消对它们的订阅。换句话说，把`flatMap`内每一条子流的依赖，替换为整个`numberStream`的依赖，这也更加符合这些流原本的概念。

我创建了帮助函数`keep`用来实现这一点。函数本身的实现看上去有些诡异，这里只放它的使用方式吧。

{% include_code index.js 18:46 %}

可以看到，在使用`takeUntilBy`终止子流之前，我先用`sampledBy`将子流的更新对齐到了`enableStream`的更新事件。这样做除了使数字在「继续」按钮被点击的一瞬间就有变化（而不是等待一个最长0.1秒的随机间隔）以外，也是为了演示在何种情况下一条流不应该通过调用`keep`的方式被传入。

----

到目前为止，我已经介绍了Butterfly的两个基本形式以及三个帮助函数：`getContext`、`overdraft`和`keep`。在写下一章又一章的过程中，我自己也对Butterfly有了更深的理解（从而想出来下一章应该怎么写），可以说我的理解只比读者领先一章左右。接下来你将会看到一个困扰了我整整一周，为了它不得不在其之前插入一章和一个间奏作为铺垫的例子。梦大概总是不得不醒的吧。
